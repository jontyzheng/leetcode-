#### Question title: [Duplicate Zeros](https://leetcode-cn.com/problems/duplicate-zeros/)/[复写零](https://leetcode-cn.com/problems/duplicate-zeros/)

tag#array#



#### Description

```
给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。

要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。

 

示例 1：

输入：[1,0,2,3,0,4,5,0]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
示例 2：

输入：[1,2,3]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]
 

提示：

1 <= arr.length <= 10000
0 <= arr[i] <= 9
```



#### Analysis

这道题目中有一个关键词——就地修改, 这很容易就想起上一道类似的题目, 也是一道要求**就地**对数组做改动的——[删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/).

印象十分深的就是其中, 原地赋值, 直接将数组项进行修改.

收到其中的启发.

接着, 回到这道题的分析.

思路: 

- 当遇到 `0` 的时候, 后面的元素要依次向后移一个位置, 然后让下一个元素变 `0`.

操作:

- 明显, 元素的移动需要借助原地赋值数组项实现. 这个时候, 肯定是不能从前往后赋值的, 因为后面的值会被这样的顺序给覆盖掉, 不是我们想要的效果. 所以考虑从后往前遍历, 将当前 `i-1`  位上的值传给当前值的第 `i` 位.
- 循环终点. 如果是重写 `0` 的话, 值为 `0` 的后一位是不会涉及到后面的 "循环移动" 的. 所以循环移动的终点位置是 k >= i + 2. 到了最后一步实际上, 是将 `i+1` 位上的值传给了我们的 `k+2` 位上.
- 发现变化: 在 `0` 值后面一排向后移动后, 下一次移动的起点应该跳到 `i+2` 位上. 下一次判断从 `i+2` 位开始判断.



#### Code

我用的是 while 循环, 结合 i++.

##### 效果

```
执行结果：
通过
显示详情
执行用时：
18 ms, 在所有 Java 提交中击败了18.63%的用户
内存消耗：40.1 MB, 在所有 Java 提交中击败了29.20%的用户
```



```java
class Solution {
    public void duplicateZeros(int[] arr) {
        if (arr.length == 1)
            return;
        int i = 0;
        while (i <= arr.length - 2) {
            if (arr[i] == 0) {
                for (int k = arr.length - 1; k >= i+2; k--) {
                arr[k] = arr[k-1];
                }
            arr[i + 1] = 0;
            i++;   // 遇到的时候在原来的基础上多移动一位, 这样实际上就跳到了后两位的位置
            }            
            i ++;   //  照常
        }
    }
}
```

