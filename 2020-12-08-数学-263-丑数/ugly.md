#### Question [263. 丑数](https://leetcode-cn.com/problems/ugly-number/)

tag##



#### Description

```
编写一个程序判断给定的数是否为丑数。

丑数就是只包含质因数 2, 3, 5 的正整数。

示例 1:

输入: 6
输出: true
解释: 6 = 2 × 3
示例 2:

输入: 8
输出: true
解释: 8 = 2 × 2 × 2
示例 3:

输入: 14
输出: false 
解释: 14 不是丑数，因为它包含了另外一个质因数 7。
说明：

1 是丑数。
输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/ugly-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```







#### Code

```java
class Solution {
    //执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户
    public boolean isUgly(int num) {
        //  小于 1 的一定不会给它们整除
        if (num < 1)    return false;   
        //  验证一个数是否会被它们整除, 其中一个或者它们几个      
        //  验证一个数是否可以把一组因数除尽的最好方法就是反复鞭尸
        //  只要没除尽, 就往死里除, 轮流除
        while(num % 2 == 0) {
            num/=2;
        }
        while (num % 3 == 0) {
            num/=3;
        }
        while (num % 5 == 0) {
            num/=5;
        }        
        if (num == 1) 
            return true;
        else
            return false;
    }
}
```





#### 分析

见注释



#### 测试用例过滤

###### I. 2357

```java
class Solution {
    public boolean isUgly(int num) {
        return !(num%7 == 0);
    }
}
```



> ```
> 输入：
> -2147483648
> 输出：
> true
> 预期：
> false
> ```
>
> 解释:
>
> 把 2, 3, 5 整除的数为丑数. 数轴上小于 1 的数字肯定不会把它们整除.



###### II. 2357+(-1)

```java
class Solution {
    public boolean isUgly(int num) {
        if (num < 1)    return false;
        return !(num%7 == 0);
    }
}
```



> ```
> 输入：
> 11
> 输出：
> true
> 预期：
> false
> ```
>
> 解释:
>
> 只是大部分**常见的数**是由 1~10 以内的"质因数"组成.
>
> 除了 2, 3, 5, 7 还有 11, 13, 17 等等.





#### 讲讲你一开始的想法

I. 刚看到题目的时候想的就是不会又要求公因数吧? 甚至还想到了上次看书中刚好提到"不用一个一个整除的判断公因数的方法", 那个还没看呢?

再看一眼数量级, 就更不可能采取那种方法了.

II.2, 3, 5 想着, 都是在 10 以内的质因数, 很自然就想到 7 了.

既然是数学题目, 会不会考的就是这种脑筋急转弯?

III.看到了第一条题解的前一步, 恍然惊醒, 对哦, 小于 1 的一定可以首先排除.

V.看了答案之后, 原来丑数还可以理解成"把一个数无限整除"!

太吊了, 反复鞭尸, 除到不能再除为止.



#### 本期leetcode	

- 不是丑数的数字: 11, 13, 17.
- 只要能除就把它除到不能再除为止. 检验一个数字是否为一组质因数的"唯一"被除数(质因数只能出现在它们其中)的最好方法就是反复除, 直到一个除不下了再扔给下一个继续除.





