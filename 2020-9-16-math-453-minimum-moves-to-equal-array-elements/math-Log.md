#### Question [最小移动次数使数组元素相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/)

tag#math#



#### Description

```
给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。

 

示例:

输入:
[1,2,3]

输出:
3

解释:
只需要3次移动（注意每次移动会增加两个元素的值）：

[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

```



#### Analysis

题意分析: 有题可得, 一个整数数组经过这样的每次 n-1 项加一的规律最后一定可以变成一个所有元素都相等的数组.

由题目给出的例子可知, 这样的"移动"一定是和顺序有关的. 拿这个例子为例, 可以看到有以下几个特点:

1. 前提是数组元素升序排列;
2. 其次, 由最右边最大的那个"移动", 让比较小的每次加一.
3. 在倒数第二次中, 其它的项都比某一个要小一, 最后一次便是由这时候最大的去完成.

解题分析:

其实, 这是第一次接触 #math# 的题, 刚接触到这一题的时候, 我就想可能会和非常规遍历会有地方不一样. 由移动的变化就可以看出些了 - 数字的变化规律.

所以我首先是将数组排序, 然后进行简单地"面向题目例子"写. 结果肯定是错误的. 总有些情况是从来考虑的, 于是从错误的测试用例中, 逐渐接触更多的用例.

如

1 2 只需移动 1 次

1 3 - 2 3 - 3 3 移动 2 次

1 2 3  - 2 2 3 - 3 4 3 - 4 4 4 移动 3 次.

但是规律是没有变的. 

在评论区的启发下后, 找到了其中的函数关系. 这时候想到的是从总数下手. 因为最后一次数组肯定是由一排相等的数组成的嘛. 于是有了以下规律:

1. 排好序的原数组, 总和为 sum.
2. 每次变化都是只有 n-1 个项变, 而那个"移动"的没变. 整体每次增加 (n-1)*1. (n 为数组中项的个数);
3. 最后一次的数组是由 n 个 max 组成的, 等于这里, `sum` 从初始状态经过等差变化到最终状态可以列出一个方程. 但是话还有一个, 最小的那个等差变化到到最大值也有一个方程.

所以就有下面两个方程:

min + m = max ①

sum + m*(n-1) = max * n; ②

两个方程只有一个未知数 m, 就可以解出来了.



#### Code

```java
class Solution {
    public int minMoves(int[] nums) {
        //  前提: 排好序
        //  其次: 最右边最大的一个"移动"
        //  由倒数第二大完成最后一次"移动", 因为移动项自己不会增加, 但是第二小的会在倒数第二次超过最大数
        //  倒数第二次的情况: 其它的都比一个数小一, 最后一次由那个最小的来完成
        Arrays.sort(nums);
        int len = nums.length;
        //  n-1 肯定是较小的那些增加. 一定是一个最大的 max, 其它相等且都为 max-1
        //  那这一种又一定是含两个最大的, 值为 max-1, 然后由其中一个完成移动达到最后一种情况.
        int max = nums[len-1];
        int sum = 0;
        for (int i = 0; i < len; i++) {
            sum += nums[i];
        }
        return sum - len * nums[0];        
    }
}
```

效果:

执行结果：

通过

显示详情

执行用时：14 ms, 在所有 Java 提交中击败了27.06%的用户

