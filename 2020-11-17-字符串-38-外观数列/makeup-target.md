#### Question [38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)

tag##



#### Description

```
给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

countAndSay(1) = "1"
countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。
前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串 "3322251" 的描述如下图：


 

示例 1：

输入：n = 1
输出："1"
解释：这是一个基本样例。
示例 2：

输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = 读 "1" = 一 个 1 = "11"
countAndSay(3) = 读 "11" = 二 个 1 = "21"
countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"
 

提示：

1 <= n <= 30
通过次数144,380提交次数2

```



#### Analysis

##### 1.外观数组是什么?

从题目可以得知, 字符串从 "1" 开始, 后面依次对字符串遍历, 记录各个数字的出现次数和出现的数字.  因为这个数列可以体现出字符串的结构, 反推出原数列, 所以称之为"外观数列".

##### 2.题目问的是什么?

已知原始字符串是 "1", 后面的每一项都是对前一项的描述(数量+数字). 如 n = 2, 对应 "11"; n = 3, 对应 "21"..

题目想要传入一个序号, 输出该数列的对应第 n 项.

##### 3.怎么入手?

其实刚看到题目的时候就理所当然地想着根据 n 是多少, 在根据 n 来构造字符串. 但是看到题解第一名的答案, 让我却肯定了自己的这一想法, 于是, 我就把所有 n 对应的字符串都求出来了, 根据 n 的需要再提取对应位置上的项.. 毕竟, n 的确定的嘛..

##### 4.操控小人闯关

在仔细分析了每一项递进的规律后, 我就画了一连串的流程图(末尾会贴上草稿). 最后终于, fq 了.

忽然转念一想, 我干嘛不拿它当作是一个小人, 就像小时候晚的坦克大战或者雪人兄弟一样, 一路上会碰到各种关卡, 各种判断条件, 然后利用手柄操控它, 作出相应的动作.

<img src="https://raw.githubusercontent.com/jontyzheng/leetcode-journal/master/2020-11-17-%E5%AD%97%E7%AC%A6%E4%B8%B2-38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/battle-city.png">



<img src="https://raw.githubusercontent.com/jontyzheng/leetcode-journal/master/2020-11-17-%E5%AD%97%E7%AC%A6%E4%B8%B2-38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/snowbros.png" width="27%">

然后, 就整理出了构造这么一个列表所需要的流程地图.



###### 流程图

1.新建一个 `StringBuilder` 的链表: 长度为 30, 用于依次存放每次构造出来的字符串(可变长字符串);

2.先将 "1" 加入中列表中, 从值为 "1" 的字符串开始每构造一个新建一个全新的 `StringBuilder`;

3.开始构造后面的 29 项;

4.每次构造完成添加进列表中;

5.根据传入的 n 返回列表对应的第 n-1 项.



##### 5.细节

中间因为忘了怎么计数字符连续出现的次数耽误了好长一段时间嘶嘶嘶嘶嘶嘶

比较"复杂"的就是上面第 3 步构造每一项的步骤了.

写流程图的看着比很容易: `11`: 看见有 2 个 1, 就先追加 2 后追加 1 就可以了. 眼睛看着很容易.

但是要写程序要求代码去走的时候就不一样了.

1.以当前字符串 s 的长度为 循环终点: 这个字符串后面会随着新的项而更新;

2.遍历字符串, 每次对当前的字符, 另外开一个循环变量 k, 从后一项开始遍历, 计数连续出现的次数. 

如果不再相等了, 就跳出循环. 每找完一次便追加到当前第 n 项的 `StringBuilder` 中.

3.计数: 因为默认的数量(后追加的)默认都是 1, 所以如果计数出来的 count 大于 1 的时候说明后面连续几项都重复了, 下次就从那个地方 i+count 项开始了.

但是注意, 因为循环因子 i 会在循环体结束后执行一次, 所以这里**跳**的时候少减一次.

4.计数只为 1 的时候: 不是每一个都要跳到 i+count 的, 那样就会跳出后面的项, 得出的字符串会少好几位. 所以只在  count 不为 1 的时候才跳, 这里加一个条件判断.

5.循环结束也就是字符串构造完成的时候了. 每结束一轮循环将已经构造好的字符串(可变字符串)添加到里列表中. 

别忘了, 更新 s 给后面的遍历循环作条件.

6.列表构造完成后, 再根据传入的 n 返回列表中第 n-1 项.



当然, 有一个缺点就是不管 n 是多少都需要用同样多的时间.



<img src="https://raw.githubusercontent.com/jontyzheng/leetcode-journal/master/2020-11-17-%E5%AD%97%E7%AC%A6%E4%B8%B2-38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/makeup-map.PNG" width="70%">

#### Code

```java
class Solution {
    //状态：执行用时: 18 ms 内存消耗: 38 MB 通过 30 / 30 个通过测试用例
    public String countAndSay(int n) {
        List<StringBuilder> list = makeupTarget();
        return list.get(n-1).toString();
    }
    
    public List<StringBuilder> makeupTarget() {
        List<StringBuilder> list = new ArrayList<>(30);
        StringBuilder headSbu = new StringBuilder("1");
        String s = headSbu.toString();
        list.add(headSbu);
        int len;
        for (int n = 0; n <= 28;n++) {
            //----------------------------------------------
            StringBuilder perSbu = new StringBuilder();    //  每一次都需要的新的 StringBuilder
            len = s.length();   //  各自的循环终点

            for (int i = 0; i < len; i++) {
                int count = 1;
                for (int j = i+1; j < len; j++) {
                    if (s.charAt(j) == s.charAt(i))
                        count++;
                    else
                        break;
                }
                perSbu.append(count);
                perSbu.append(s.charAt(i));
                if (count > 1) {
                    i += count - 1;
                }
            }
            s = perSbu.toString();  //  下一次准备遍历的字符串
            list.add(perSbu) ;
            //-------------------------------------------------
        }
        return list;
    }
}
```





#### 本期心情						

做出来就很舒服, 说明可行.



