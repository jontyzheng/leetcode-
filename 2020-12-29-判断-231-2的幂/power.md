#### Question [231. 2的幂](https://leetcode-cn.com/problems/power-of-two/)

tag#数学#



#### Description

```
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

示例 1:

输入: 1
输出: true
解释: 20 = 1
示例 2:

输入: 16
输出: true
解释: 24 = 16
示例 3:

输入: 218
输出: false
```







#### Code

```java
class Solution {
    //执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户
    public boolean isPowerOfTwo(int n) {
        //  2 的  0 次方
        if (n == 1)
            return true;
        //  奇数的排除
        if (n % 2 == 1) 
            return false;            
        //  如果偶数连续整除 2 直至商为 1         
        while (n > 1 && n % 2 == 0) {
            n = n/2;    //  连续对 2 作除法
        }
        return n == 1;
    }
}
```







#### 分析

##### 题目的概念

给定一个数, 判断它是不是 2 的 n 次方, 或者说它能不能连续除以 2 直至结果为 1.

根据给出的测试用例我们可知, 2 的 0 次方等于 1, 1 一定是满足条件的.

然后, 奇数一定是要给排除的. 因为它根本第一次就无法整除 2, 更不用说反复整除 2 了.

后面的就是反复作除法判断后更新, 并判断最后留下的值会不会是 1.

如果是 3 的话, 不会走 while 方法体, 最后留下的也是 3,  3 就可以指判断它一定不是 2 的 n 次方.





#### 测试用例过滤

-





#### 讲讲你一开始的想法

就是先看测试用例

刚看到 2 的 n 次方就有些想法, 

然后测试用例也给出了 1 这种比较容易忽略的情况.

在写 while 的时候忽然想到**奇数**一定是不满足条件的, though.

在写 while 的过程中, 又想是要经过除法和更新两步呢还是

然后很容易就在 while 的判断语句添加了对奇数的排除判断. 因为刚好想到了 `6/2 == 3` 的情形.

就是这样.





#### 本期leetcode	

2<sup>0</sup> = 1



